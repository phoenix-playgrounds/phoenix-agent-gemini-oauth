# Phoenix Agent

A multi-provider AI agent that operates headlessly in Docker, authenticating via OAuth and communicating with a Rails backend over ActionCable.

## Supported Providers

| Provider | `AGENT_PROVIDER` value | Status |
|---|---|---|
| Gemini CLI | `gemini` (default) | âœ… Fully implemented |
| Claude Code | `claude_code` | ðŸš§ Stub |
| OpenAI Codex | `openai_codex` | ðŸš§ Stub |
| OpenCode | `opencode` | ðŸš§ Stub |
| Mock | `mock` | âœ… For testing (instant success, no real CLI calls) |

## Environment Variables

| Variable | Required | Default | Description |
|---|---|---|---|
| `WS_URL` | Yes | `ws://localhost:8080/cable` | ActionCable WebSocket endpoint |
| `PLAYGROUND_ID` | Yes | â€” | ID of the playground this agent serves |
| `AGENT_SECRET` | Yes | â€” | Secret for authenticating with the Rails AgentChannel |
| `AGENT_PROVIDER` | No | `gemini` | Which AI CLI provider to use (set to `mock` for testing) |

## Architecture

The agent uses a **strategy pattern** to support multiple AI providers:

```
src/
â”œâ”€â”€ index.mjs              # Entrypoint, graceful shutdown
â”œâ”€â”€ agent.mjs              # Starts the ActionCable consumer
â”œâ”€â”€ agent_connection.mjs   # ActionCable transport layer
â”œâ”€â”€ websocket.mjs          # Orchestrator (wires events to strategy)
â””â”€â”€ strategies/
    â”œâ”€â”€ base.mjs           # Abstract interface
    â”œâ”€â”€ index.mjs          # Strategy resolver (reads env vars)
    â”œâ”€â”€ gemini.mjs         # Gemini CLI implementation
    â”œâ”€â”€ mock.mjs           # Mock provider (for testing)
    â”œâ”€â”€ claude_code.mjs    # Stub
    â”œâ”€â”€ openai_codex.mjs   # Stub
    â””â”€â”€ opencode.mjs       # Stub
```

The `resolveStrategy()` function in `strategies/index.mjs` reads `AGENT_PROVIDER` (default: `gemini`) and returns the matching strategy instance.

## Testing

- Run unit tests: `npm test`
- Run integration tests: `node tests/integration.mjs`
- Run linter: `npm run lint`

For integration tests, a mock WebSocket server and a mock `gemini` executable in `tests/bin/` prevent hitting actual provider servers.

## ActionCable Event Types & Workflows

### Event Types Consumed (from Rails server)

*   **`{action: "initiate_auth"}`**: Triggers the provider authentication process.
*   **`{action: "submit_auth_code", code: "..."}`**: Submits the authorization code to the auth process.
*   **`{action: "cancel_auth"}`**: Cancels the current authentication process.
*   **`{action: "reauthenticate"}`**: Clears credentials and restarts authentication.
*   **`{action: "check_auth_status"}`**: Requests the current authentication status.
*   **`{action: "send_chat_message", text: "..."}`**: Sends a prompt to the AI provider. Prepends `SYSTEM_PROMPT.md` contents.

### Event Types Produced (to Rails server)

*   **`{action: "auth_url_generated", url: "..."}`**: The OAuth consent URL generated by the provider.
*   **`{action: "auth_success"}`**: Authentication succeeded. Agent is ready for prompts.
*   **`{action: "auth_status", status: "authenticated" | "unauthenticated"}`**: Current auth status.
*   **`{action: "chat_message_in", text: "..."}`**: Successful prompt output.
*   **`{action: "error", message: "..."}`**: Error, `NEED_AUTH`, or `BLOCKED`.
*   **`{action: "ping"}`**: Keep-alive heartbeat.

### Workflows

#### 1. Authentication Workflow
1. Client sends `{action: "initiate_auth"}`.
2. Agent checks auth status via the provider strategy.
3. If not authenticated, agent starts the provider's auth flow.
4. Agent responds `{action: "auth_url_generated", url: "..."}`.
5. User authorizes via browser and copies the code.
6. Client sends `{action: "submit_auth_code", code: "<code>"}`.
7. Agent writes code to the provider's auth process.
8. Agent replies `{action: "auth_success"}`.

#### 2. Prompt Execution Workflow
1. Ensure the agent is authenticated.
2. Client sends `{action: "send_chat_message", text: "<user message>"}`.
3. Agent prepends `SYSTEM_PROMPT.md` to the user message.
4. Agent executes the prompt via the provider strategy.
5. Upon success: `{action: "chat_message_in", text: "..."}`.
6. Upon error: `{action: "error", message: "..."}`.

#### 3. Status Checking
*   Client sends `{action: "check_auth_status"}` â†’ Agent responds with `{action: "auth_status", status: "authenticated" | "unauthenticated"}`.
