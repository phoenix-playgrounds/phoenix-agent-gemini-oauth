# Phoenix Agent

This project is aimed to allow using gemini-cli tool in headless mode in order to make changes to multiple repositories mounted through SSHFS

## Features

- Authenticate gemini-cli using oAuth asyncronously using websocket messages
- Backend responsible for business logic is a Rails application to which we connect through ActionCable protocol
- Once authentication is succesfull, agent is ready to listen websocket messages that will be translated to actual prompts to gemini-cli like: `gemini -p "$USER_MESSAGE"
- Agent must be COMPLETELY and ENTIRELY autonomous without requesting access, asking follow-up questions or execution plan confirmations
- Once finished, agent must sent a message to the Rails backend through ActionCable channel and some summary/final message that will actualy asnwer user's prompt

## Testing

- Run unit tests with `npm test`
- For integration tests, a mock WebSocket server (`ws`) and a mock `gemini` executable are provided to prevent hitting actual Gemini servers.
- Run integration tests with `node tests/integration.mjs`

## ActionCable Event Types & Workflows

The Agent consumes and produces a strict set of JSON payloads over the ActionCable `AuthChannel`.

### Event Types Consumed (from Rails server)

*   **`{"start_auth": true}`**: Triggers the Gemini authentication process. The agent will respond with `url_generated`.
*   **`{"auth_code": "..."}`**: Submits the authorization code (retrieved from the OAuth URL) to the Gemini process.
*   **`{"prompt": "..."}`**: Sends a prompt to be executed by Gemini. If sent before authentication, it returns `NEED_AUTH`. If sent while another prompt is running, it returns `BLOCKED`. All prompts are implicitly prepended with the contents of `SYSTEM_PROMPT.md`.
*   **`{"type": "STATUS"}`** (or `{"status": true}`): Requests the current processing status of the agent.
*   **`{"type": "AUTH_STATUS"}`** (or `{"auth_status": true}`): Requests the current authentication status of the agent.

### Event Types Produced (to Rails server)

*   **`{"action": "url_generated", "url": "..."}`**: The initial OAuth consent URL generated by `gemini login`.
*   **`{"action": "auth_success", "status": "completed"}`**: Confirmation that authentication has succeeded. The agent is now ready to accept prompts.
*   **`{"action": "prompt_completed", "result": "..."}`**: The successful text output emitted by the Gemini CLI command.
*   **`{"action": "prompt_failed", "error": "..."}`**: Sent if a prompt fails to execute, or if it is blocked by active concurrent tasks (`BLOCKED`) or lacking credentials (`NEED_AUTH`).
*   **`{"action": "STATUS_RESPONSE", "status": "WAITING" | "BLOCKED"}`**: Sent in response to a `STATUS` generic request. `WAITING` means idle; `BLOCKED` means currently busy processing a prompt.
*   **`{"action": "AUTH_STATUS_RESPONSE", "status": "NEED_AUTH" | "ALREADY_AUTH"}`**: Sent in response to an `AUTH_STATUS` generic request.

### Workflows

#### 1. Authentication Workflow
1. Client connects via WS and subscribes to `AuthChannel`.
2. Client sends `{"start_auth": true}`.
3. Agent spawns `gemini login`, extracts the URL, and responds `{"action": "url_generated", "url": "..."}`.
4. User authorizes via browser and copies the code.
5. Client sends `{"auth_code": "<code>"}`.
6. Agent writes code to `gemini login` stdin.
7. Agent replies `{"action": "auth_success", "status": "completed"}`.

#### 2. Prompt Execution Workflow
1. Ensure the agent is authenticated.
2. Client sends `{"prompt": "<user message>"}`.
3. Agent prepends the contents of `SYSTEM_PROMPT.md` to the user message.
4. Agent executes `gemini --yolo -p <concatenated_prompt>` inside the `playground` directory.
5. Upon success, Agent replies `{"action": "prompt_completed", "result": "..."}`.
6. Upon error, Agent replies `{"action": "prompt_failed", "error": "..."}`.

#### 3. Status Checking Workflows
*   **Is Busy?**: Client sends `{"type": "STATUS"}` -> Agent responds instantly with `{"action": "STATUS_RESPONSE", "status": "WAITING"}` or `"BLOCKED"`.
*   **Is Authenticated?**: Client sends `{"type": "AUTH_STATUS"}` -> Agent responds instantly with `{"action": "AUTH_STATUS_RESPONSE", "status": "NEED_AUTH"}` or `"ALREADY_AUTH"`.
